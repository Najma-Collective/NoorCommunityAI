<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nour - AI Tutor</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Questrial&family=Marcellus&display=swap" rel="stylesheet">
    
    <!-- Markdown Library -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- PDF Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* =====================================================================
           DESIGN SYSTEM
           ===================================================================== */
        :root {
            /* Palette - Sage Theme (Default) */
            --primary-color: #3d5a3d;       /* Deep forest green */
            --secondary-color: #7a9b7a;     /* Sage green */
            --accent-color: #e67e22;        /* Warm orange */
            --bg-color: #f5f1e8;            /* Cream */
            --glass-bg: rgba(255, 255, 255, 0.9);
            --glass-border: rgba(255, 255, 255, 0.9);
            --text-dark: #2a3328;

            /* Text Highlights (The Key) */
            --hl-vocab-bg: #ffe8cc;         /* Light orange for Vocab */
            --hl-vocab-text: #d35400;       /* Dark orange */
            --hl-grammar-bg: #d4e8d4;       /* Light sage for Grammar */
            --hl-grammar-text: #3d5a3d;     /* Deep green */
            --hl-alert-bg: #fce8e8;         /* Soft Rose for Correction */
            --hl-alert-text: #8b3a3a;       /* Dark red */   

            /* Fonts */
            --font-display: "Marcellus", serif; 
            --font-body: "Nunito", sans-serif;
            --font-ui: "Questrial", sans-serif;
        }

        /* Ocean Theme */
        body.theme-ocean {
            --primary-color: #0d4d4d;       /* Dark teal */
            --secondary-color: #2a7676;     /* Teal */
            --accent-color: #e67e22;        /* Warm orange */
            --hl-vocab-bg: #ffe8cc;
            --hl-vocab-text: #d35400;       /* Dark orange */
            --hl-grammar-bg: #d4f1f1;       /* Light teal */
            --hl-grammar-text: #0d4d4d;     /* Dark teal */
            --hl-alert-text: #8b3a3a;       /* Dark red */
            --bg-color: #f0f5f5;            /* Light teal cream */
        }
        
        *, *::before, *::after { box-sizing: border-box; }

        body {
            margin: 0; height: 100dvh; font-family: var(--font-body);
            color: var(--text-dark); font-size: 16px;
            overflow: hidden; background: var(--bg-color); transition: background 0.8s ease;
        }

        /* Animation Canvas */
        #wave-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; opacity: 0.5; }

        #app-wrapper {
            position: relative; z-index: 1; display: flex; align-items: center; justify-content: center;
            height: 100%; padding: 2vh;
        }

        #activity-container {
            width: 100%; max-width: 1400px; height: 96vh;
            display: grid; grid-template-columns: 1fr 340px; grid-template-rows: auto 1fr auto;
            background: var(--glass-bg); backdrop-filter: blur(40px); -webkit-backdrop-filter: blur(40px);
            border-radius: 32px; border: 1px solid var(--glass-border);
            box-shadow: 0 30px 90px -20px rgba(42, 51, 40, 0.15); overflow: hidden;
        }

        /* --- HEADER --- */
        .chat-header {
            grid-column: 1 / -1; padding: 1.2rem 2.5rem;
            background: rgba(255,255,255,0.4); border-bottom: 1px solid rgba(0,0,0,0.03);
            display: flex; align-items: center; justify-content: space-between;
        }
        
        .header-left { display: flex; align-items: center; gap: 1.2rem; }
        .header-info h1 { font-family: var(--font-display); margin: 0; font-size: 1.4rem; color: var(--primary-color); }
        .header-status { font-family: var(--font-ui); font-size: 0.8rem; color: var(--secondary-color); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }

        .avatar-wrapper {
            position: relative; width: 60px; height: 60px;
            display: flex; align-items: center; justify-content: center;
        }
        .avatar-circle {
            width: 100%; height: 100%; border-radius: 50%;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
            background-size: 400% 400%;
            position: relative; z-index: 2;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4),
                        0 4px 16px rgba(246, 147, 251, 0.3),
                        inset 0 2px 6px rgba(255,255,255,0.4),
                        inset 0 -2px 6px rgba(0,0,0,0.1);
            animation: orbFloat 6s ease-in-out infinite, gradientShift 12s ease infinite;
            transition: all 0.3s ease;
        }
        .avatar-circle::before {
            content: '';
            position: absolute;
            inset: 4px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.5), transparent 50%);
            pointer-events: none;
            animation: shimmer 3s ease-in-out infinite;
        }
        .avatar-circle::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(0,0,0,0.05) 100%);
            pointer-events: none;
        }
        .avatar-aura {
            position: absolute; inset: -8px; border-radius: 50%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.6) 0%, rgba(246, 147, 251, 0.4) 50%, rgba(79, 172, 254, 0.2) 100%);
            opacity: 0.5; z-index: 1;
            animation: breathe 5s ease-in-out infinite;
            filter: blur(12px);
        }

        /* Avatar Animations */
        .avatar-wrapper.listening .avatar-aura {
            animation: pulseFast 0.8s infinite;
            background: radial-gradient(circle, rgba(212, 163, 115, 0.8) 0%, rgba(141, 163, 134, 0.6) 100%);
            opacity: 0.8;
            filter: blur(16px);
        }
        .avatar-wrapper.listening .avatar-circle {
            animation: orbFloat 6s ease-in-out infinite, gradientShift 3s ease infinite, inputPulse 1.5s ease-in-out infinite;
        }
        .avatar-wrapper.speaking .avatar-circle {
            animation: speakPulse 0.6s ease-in-out infinite, gradientShift 8s ease infinite;
            box-shadow: 0 8px 40px rgba(102, 126, 234, 0.6),
                        0 4px 20px rgba(246, 147, 251, 0.5),
                        inset 0 2px 6px rgba(255,255,255,0.4);
        }
        .avatar-wrapper.typing .avatar-circle {
            animation: orbFloat 6s ease-in-out infinite, gradientShift 6s ease infinite, typingGlow 2s ease-in-out infinite;
        }

        @keyframes orbFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-4px) scale(1.03); }
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes shimmer {
            0%, 100% { opacity: 0.5; transform: rotate(0deg); }
            50% { opacity: 0.8; transform: rotate(10deg); }
        }
        @keyframes inputPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }
        @keyframes typingGlow {
            0%, 100% {
                box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4),
                            0 4px 16px rgba(246, 147, 251, 0.3);
            }
            50% {
                box-shadow: 0 8px 40px rgba(102, 126, 234, 0.6),
                            0 4px 24px rgba(246, 147, 251, 0.5);
            }
        }

        /* --- CHAT AREA --- */
        #chat-history {
            grid-column: 1 / 2; grid-row: 2 / 3;
            overflow-y: auto; padding: 3rem;
            display: flex; flex-direction: column; gap: 2rem; scroll-behavior: smooth;
        }

        .message {
            max-width: 85%; opacity: 0; 
            animation: floatIn 0.5s forwards; line-height: 1.7;
        }

        .message.ai {
            align-self: flex-start; width: 100%; max-width: 90%;
            font-size: 1.05rem; color: var(--text-dark);
        }
        
        .message.user {
            align-self: flex-end; padding: 1rem 1.5rem;
            color: white; border-radius: 20px 20px 4px 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            box-shadow: 0 8px 20px -5px rgba(92, 107, 83, 0.3);
        }

        .message.error {
            align-self: center; background: #ffebee; color: #c62828;
            padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.9rem;
        }

        /* --- AI VISUAL COMPONENTS (CARDS & CAROUSELS) --- */
        
        /* Carousel Container */
        .carousel {
            display: flex; gap: 1.5rem; overflow-x: auto; 
            padding: 1.5rem 0.5rem; margin: 1rem 0;
            scroll-snap-type: x mandatory;
        }
        .carousel::-webkit-scrollbar { height: 6px; }
        .carousel::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 10px; }

        /* Learning Card */
        .learning-card {
            flex: 0 0 260px; scroll-snap-align: center;
            background: #fff; border-radius: 20px;
            padding: 1.5rem; position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            border: 1px solid rgba(255,255,255,0.8);
            transition: transform 0.3s ease;
            display: flex; flex-direction: column;
        }
        .learning-card:hover { transform: translateY(-5px); }
        .learning-card h3 { 
            font-family: var(--font-display); color: var(--primary-color); 
            margin-top: 0; border-bottom: 2px solid var(--accent-color); padding-bottom: 8px;
        }

        /* Dialogue Box - Organic Speech Bubble */
        .dialogue-box {
            background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(248,250,247,0.8) 100%);
            border-radius: 24px 24px 24px 4px;
            padding: 1.8rem 2.2rem;
            margin: 2rem 0;
            box-shadow: 0 8px 32px rgba(92, 107, 83, 0.12),
                        inset 0 1px 0 rgba(255,255,255,0.9);
            position: relative;
            border: 1px solid rgba(92, 107, 83, 0.08);
        }
        .dialogue-box::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 20px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid rgba(255,255,255,0.9);
        }
        .dialogue-speaker {
            font-family: var(--font-display);
            font-size: 1.1rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .dialogue-speaker::before {
            content: 'üí¨';
            font-size: 1.2rem;
        }
        .dialogue-content {
            line-height: 1.8;
            color: var(--text-dark);
        }
        .dialogue-content p {
            margin: 0.8rem 0;
        }
        .dialogue-content p:first-child {
            margin-top: 0;
        }
        .dialogue-content p:last-child {
            margin-bottom: 0;
        }
        /* Legacy support for old format */
        .d-line { margin-bottom: 1rem; display: flex; gap: 1rem; }
        .d-name { font-weight: 800; min-width: 80px; color: var(--primary-color); font-family: var(--font-display); }

        /* Highlights */
        .hl-vocab { background: var(--hl-vocab-bg); color: var(--hl-vocab-text); padding: 2px 6px; border-radius: 4px; font-weight: 700; border-bottom: 2px solid rgba(0,0,0,0.1); }
        .hl-grammar { background: var(--hl-grammar-bg); color: var(--hl-grammar-text); padding: 2px 6px; border-radius: 4px; font-weight: 700; border: 1px dashed var(--secondary-color); }
        .hl-feedback { background: var(--hl-alert-bg); color: var(--hl-alert-text); padding: 2px 6px; border-radius: 4px; text-decoration: underline wavy; }

        /* Metacognitive Widgets */
        .think-prompt {
            background: linear-gradient(135deg, #f8f4ff 0%, #ede7f6 100%);
            border-left: 4px solid #9575cd;
            padding: 1.5rem;
            border-radius: 12px;
            margin: 1.5rem 0;
            font-style: italic;
            color: #4a148c;
            box-shadow: 0 4px 12px rgba(149, 117, 205, 0.1);
        }
        .think-prompt strong {
            font-style: normal;
            display: block;
            margin-bottom: 0.5rem;
            font-family: var(--font-display);
        }

        .notice-box {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border: 2px solid #ffa726;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            color: #e65100;
            position: relative;
            box-shadow: 0 4px 12px rgba(255, 167, 38, 0.15);
        }
        .notice-box strong {
            display: block;
            margin-bottom: 0.5rem;
            font-family: var(--font-display);
            font-size: 1.1rem;
        }

        .success-badge {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #66bb6a;
            border-radius: 20px;
            padding: 0.75rem 1.5rem;
            margin: 1rem 0;
            color: #2e7d32;
            font-weight: 700;
            display: inline-block;
            box-shadow: 0 4px 12px rgba(102, 187, 106, 0.2);
            animation: successPop 0.5s ease-out;
        }

        @keyframes successPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Self-Assessment Widget */
        .self-check {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border: 2px solid var(--secondary-color);
        }
        .self-check h4 {
            font-family: var(--font-display);
            color: var(--primary-color);
            margin-top: 0;
        }
        .confidence-scale {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: space-between;
        }
        .confidence-option {
            flex: 1;
            padding: 0.75rem;
            background: #fff;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        .confidence-option:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* Sentence Stems Helper */
        .sentence-stems {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #2196f3;
        }
        .sentence-stems h4 {
            font-family: var(--font-display);
            color: #0d47a1;
            margin-top: 0;
            font-size: 1rem;
        }
        .stem-option {
            background: white;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            color: #1565c0;
            font-style: italic;
            border-left: 3px solid #42a5f5;
        }

        /* Progress Indicator Enhancement */
        .mini-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            margin: 1rem 0;
            font-size: 0.85rem;
        }
        .progress-bar {
            flex: 1;
            height: 6px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            transition: width 0.5s ease;
        }

        /* --- SIDEBAR (NAVIGATOR) --- */
        #side-panel {
            grid-column: 2 / 3; grid-row: 2 / 4;
            background: rgba(255,255,255,0.5); border-left: 1px solid rgba(255,255,255,0.5);
            display: flex; flex-direction: column; overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .panel-header {
            padding: 1.5rem; font-family: var(--font-display); font-weight: 700; 
            color: var(--primary-color); background: rgba(255,255,255,0.3);
        }

        #tracker-container {
            flex: 1; overflow-y: auto; padding: 0 1.5rem 1.5rem 1.5rem;
        }
        
        .step-item {
            position: relative; padding: 0 0 1.5rem 1.5rem;
            border-left: 2px solid #e0e0e0;
        }
        .step-item:last-child { border-left: 2px solid transparent; }
        .step-dot {
            position: absolute; left: -7px; top: 0; width: 12px; height: 12px; 
            border-radius: 50%; background: #e0e0e0; border: 2px solid #fff; transition: all 0.3s;
        }
        .step-title { font-size: 0.8rem; color: #999; font-weight: 700; }

        .step-item.active .step-dot { background: var(--accent-color); transform: scale(1.3); }
        .step-item.active .step-title { color: var(--accent-color); }
        .step-item.done .step-dot { background: var(--primary-color); }
        .step-item.done { border-left-color: var(--primary-color); }

        /* Vocabulary Wallet Items */
        .vocab-item {
            background: linear-gradient(135deg, rgba(255, 232, 204, 0.3), rgba(255, 245, 230, 0.5));
            border-left: 3px solid var(--accent-color);
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            animation: vocabSlideIn 0.4s ease-out;
        }
        .vocab-item:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.15);
        }
        .vocab-word {
            font-weight: 700;
            color: var(--hl-vocab-text);
            font-size: 0.95rem;
            display: block;
            margin-bottom: 0.25rem;
        }
        .vocab-context {
            font-size: 0.75rem;
            color: #666;
            font-style: italic;
            line-height: 1.4;
        }
        @keyframes vocabSlideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* --- INPUT --- */
        .input-area {
            grid-column: 1 / 2; grid-row: 3 / 4;
            padding: 2rem 3rem; display: flex; gap: 1rem; align-items: flex-end;
        }
        
        .input-wrapper {
            flex: 1; background: #fff; border-radius: 28px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.05);
            display: flex; align-items: center; padding: 6px 6px 6px 20px;
        }
        
        textarea {
            width: 100%; border: none; background: transparent;
            font-family: var(--font-body); font-size: 1rem; outline: none; resize: none; max-height: 120px;
        }

        button.icon-btn {
            width: 44px; height: 44px; border-radius: 50%; border: none; background: transparent; 
            cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;
            color: #aaa;
        }
        button.icon-btn:hover { background: #f5f5f5; color: var(--primary-color); }
        
        #mic-btn.listening { background: var(--hl-alert-text); color: white; animation: pulseRed 1.5s infinite; }
        #send-btn { width: 48px; height: 48px; background: var(--primary-color); color: white; border-radius: 20px; opacity: 0.9; }
        #send-btn:hover { opacity: 1; transform: scale(1.05); }

        /* Animations */
        @keyframes breathe { 0%, 100% { transform: scale(1); opacity: 0.3; } 50% { transform: scale(1.1); opacity: 0.15; } }
        @keyframes floatIn { from { opacity:0; transform: translateY(10px); } to { opacity:1; transform: translateY(0); } }
        @keyframes pulseFast { 0% { transform: scale(1); opacity: 0.6; } 100% { transform: scale(1.2); opacity: 0.0; } }
        @keyframes pulseRed { 0% { box-shadow: 0 0 0 0 rgba(196, 90, 90, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(196, 90, 90, 0); } 100% { box-shadow: 0 0 0 0 rgba(196, 90, 90, 0); } }
        @keyframes speakPulse { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }

        /* API Modal */
        #api-modal { position: fixed; inset: 0; background: rgba(240, 242, 239, 0.95); z-index: 999; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-box { background: white; padding: 3rem; border-radius: 32px; width: 90%; max-width: 450px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.1); }
        .api-input { width: 100%; padding: 14px; margin: 1.5rem 0; border: 2px solid #eee; border-radius: 12px; outline: none; }
        .start-btn { width: 100%; padding: 16px; background: var(--primary-color); color: white; border: none; border-radius: 99px; font-weight: 700; cursor: pointer; }
        .upload-trigger-btn { width: 100%; padding: 10px; background: var(--secondary-color); color: white; border: none; border-radius: 12px; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
        .upload-trigger-btn:hover { background: var(--primary-color); transform: translateY(-1px); }

        /* Mobile Responsive Design */
        @media (max-width: 1024px) {
            #activity-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
                max-width: 100%;
                height: 100vh;
                border-radius: 0;
            }

            #side-panel {
                grid-column: 1 / -1;
                grid-row: 4 / 5;
                max-height: 200px;
                border-left: none;
                border-top: 1px solid rgba(255,255,255,0.5);
            }

            #chat-history {
                padding: 1.5rem;
                grid-column: 1 / -1;
            }

            .input-area {
                grid-column: 1 / -1;
                padding: 1rem 1.5rem;
            }

            .chat-header {
                padding: 1rem 1.5rem;
            }

            .avatar-wrapper {
                width: 50px;
                height: 50px;
            }

            .header-info h1 {
                font-size: 1.2rem;
            }

            .learning-card {
                flex: 0 0 220px;
            }

            .modal-box {
                padding: 2rem;
            }
        }

        @media (max-width: 640px) {
            #app-wrapper {
                padding: 0;
            }

            #activity-container {
                height: 100vh;
                border-radius: 0;
            }

            .chat-header {
                padding: 0.75rem 1rem;
            }

            .avatar-wrapper {
                width: 44px;
                height: 44px;
            }

            #chat-history {
                padding: 1rem;
                gap: 1.5rem;
            }

            .input-area {
                padding: 0.75rem 1rem;
            }

            .message.ai {
                font-size: 0.95rem;
            }

            .learning-card {
                flex: 0 0 200px;
                padding: 1rem;
            }

            .dialogue-box {
                padding: 1.2rem 1.5rem;
            }

            #side-panel {
                max-height: 180px;
            }

            .panel-header {
                padding: 1rem;
                font-size: 0.8rem;
            }

            .modal-box {
                padding: 1.5rem;
                width: 95%;
            }
        }

        /* Performance & Stability */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Loading State */
        .loading-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(0,0,0,0.1);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

    </style>
</head>
<body class="theme-sage">

    <canvas id="wave-canvas"></canvas>

    <div id="app-wrapper">
        <div id="activity-container">
            
            <!-- HEADER -->
            <div class="chat-header">
                <div class="header-left">
                    <div class="avatar-wrapper" id="avatar-wrapper">
                        <div class="avatar-aura"></div>
                        <div class="avatar-circle"></div>
                    </div>
                    <div class="header-info">
                        <h1>Nour</h1>
                        <div class="header-status" id="header-status">Waiting</div>
                    </div>
                </div>

                <div style="display:flex; gap:10px;">
                    <button class="icon-btn" id="sound-btn" title="Toggle Sound">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    </button>
                    <button class="icon-btn" id="theme-btn" title="Switch Theme">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    </button>
                </div>
            </div>

            <!-- CHAT -->
            <div id="chat-history"></div>

            <!-- SIDEBAR -->
            <div id="side-panel">
                <div class="panel-header">Session Map</div>
                <div id="tracker-container"></div>

                <!-- RAG Upload Section -->
                <div style="padding: 1.5rem; border-top: 1px solid rgba(0,0,0,0.05);">
                    <div style="font-family: var(--font-display); font-size: 0.9rem; color: var(--primary-color); margin-bottom: 1rem; font-weight: 700;">üìö Lesson & Progress</div>

                    <!-- Lesson Upload -->
                    <div style="margin-bottom: 1rem;">
                        <label for="lesson-upload" style="display: block; font-size: 0.75rem; color: var(--secondary-color); margin-bottom: 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Load Lesson (XML)</label>
                        <input type="file" id="lesson-upload" accept=".xml" style="display: none;">
                        <button id="lesson-upload-btn" class="upload-trigger-btn">Choose Lesson File</button>
                        <div id="lesson-status" style="font-size: 0.8rem; margin-top: 0.5rem; color: #999; font-style: italic;">No lesson loaded</div>
                    </div>

                    <!-- Progress Upload -->
                    <div>
                        <label for="progress-upload" style="display: block; font-size: 0.75rem; color: var(--secondary-color); margin-bottom: 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Load Progress (JSON)</label>
                        <input type="file" id="progress-upload" accept=".json" style="display: none;">
                        <button id="progress-upload-btn" class="upload-trigger-btn">Choose Progress File</button>
                        <div id="progress-status" style="font-size: 0.8rem; margin-top: 0.5rem; color: #999; font-style: italic;">No progress data</div>
                    </div>
                </div>

                <!-- Vocabulary Wallet -->
                <div style="padding: 1.5rem; border-top: 1px solid rgba(0,0,0,0.05); flex: 1; overflow-y: auto;">
                    <div style="font-family: var(--font-display); font-size: 0.9rem; color: var(--primary-color); margin-bottom: 1rem; font-weight: 700;">üìö Vocabulary Wallet</div>
                    <div id="vocab-wallet" style="display: flex; flex-direction: column; gap: 0.75rem;">
                        <div style="font-size: 0.85rem; color: #999; font-style: italic; text-align: center; padding: 2rem 1rem;">
                            Vocabulary words will appear here as you learn them...
                        </div>
                    </div>
                </div>

                <div style="margin-top:auto; padding:1.5rem; display:flex; flex-direction:column; gap:0.75rem;">
                    <button class="start-btn" id="download-progress-btn" style="font-size:0.85rem; padding:10px; background:var(--secondary-color);">üíæ Download Progress (JSON)</button>
                    <button class="start-btn" id="download-report-btn" style="font-size:0.85rem; padding:10px;">üìÑ Download Lesson Report (PDF)</button>
                </div>
            </div>

            <!-- INPUT -->
            <div class="input-area">
                <div class="input-wrapper">
                    <textarea id="user-input" placeholder="Type or tap microphone..." rows="1"></textarea>
                    <button class="icon-btn" id="mic-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    </button>
                </div>
                <button class="icon-btn" id="send-btn" style="color:white;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- MODAL -->
    <div id="api-modal">
        <div class="modal-box">
            <h1 style="font-family:var(--font-display); color:var(--primary-color);">Welcome Back</h1>
            <p>Please enter your Gemini API Key to begin.</p>
            <input type="password" id="api-key-input" class="api-input" placeholder="Paste API Key here...">
            <button class="start-btn" id="start-session-btn">Start Session</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const MODEL_NAME = 'gemini-2.5-flash';
        let GEMINI_API_KEY = '';
        
        // --- STAGES FOR TRACKER ---
        const STAGES = [
            "Lead-in",
            "Pre task A (Activate)",
            "Pre task B (Model)",
            "Pre task C (Lang Focus)",
            "Pre task D (Pron)",
            "Task Prep",
            "Main Task",
            "Reporting",
            "Feedback"
        ];

        // --- SYSTEM PROMPT (Pedagogically Enhanced) ---
        // ===================================================================
        // RAG SYSTEM: MODULAR PROMPT ARCHITECTURE
        // ===================================================================
        // The prompt is now split into three parts:
        // 1. BASE_PROMPT (constant): Core identity, pedagogy, formatting rules
        // 2. LESSON_PROMPT (variable): Loaded from XML lesson files
        // 3. STUDENT_CONTEXT (variable): Generated from JSON progress data via RAG

        const BASE_PROMPT = `
You are Nour, an AI tutor. You are calm, patient, and supportive. Your goal is to guide the student through a TBL lesson using visual HTML layouts.

### CRITICAL TEACHING PRINCIPLES

**TEACHER TALK: KEEP IT LOW**
- Less is more. Students learn by doing and speaking, not by reading walls of text.
- Your responses should be SHORT (2-3 sentences max in most cases).
- Ask more than you tell. Be dialogic, not monologic.
- Give students space to think and respond.

**LANGUAGE LEVEL**
- ALWAYS match the student's language level in your instructions and explanations.
- If the student is B1, use B1-level language. If A2, use A2-level language.
- Simple, clear, natural language - not academic or overly formal.

**DON'T REPEAT YOURSELF**
- NEVER give instructions in text AND then again in cards.
- Choose ONE format: either write it in prose OR put it in a card, not both.
- Example of what NOT to do: "Here are three questions. [then showing the same 3 questions in cards]"
- Instead, just show the cards directly with minimal introduction: "Let's start with a question:" [then one card]

### CRITICAL: FIRST MESSAGE REQUIREMENT
Your very first message MUST begin with a privacy disclaimer using this exact format:
\`\`\`html
<div class="notice-box">
<strong>üîí Privacy First:</strong> Please do not share any personal information, sensitive data, or private details during our session. Keep our conversation focused on learning.
</div>
\`\`\`

After the privacy notice, warmly greet the student with ONE short sentence and begin naturally.

### VISUAL & FORMATTING RULES (STRICT)
1.  **NO MARKDOWN LISTS**: When presenting options, steps, or choices, you MUST use the \`<div class="carousel">\` layout with cards inside:
    \`\`\`html
    <div class="carousel">
        <div class="learning-card">
            <h3>Question 1</h3>
            <p>What's the first thing that comes to mind when you hear "software project"?</p>
        </div>
        <div class="learning-card">
            <h3>Question 2</h3>
            <p>Can you recall any challenges teams might face when developing software?</p>
        </div>
        <div class="learning-card">
            <h3>Question 3</h3>
            <p>What makes a software project successful, in your opinion?</p>
        </div>
    </div>
    \`\`\`
2.  **HIGHLIGHTS**:
    -   Vocabulary: \`<span class="hl-vocab">term</span>\`
    -   Grammar: \`<span class="hl-grammar">structure</span>\`
    -   Correction/Feedback: \`<span class="hl-feedback">correction</span>\`
3.  **DIALOGUES**: When showing conversations or monologues, use this NEW format:
    \`\`\`html
    <div class="dialogue-box">
        <div class="dialogue-speaker">Nour</div>
        <div class="dialogue-content">
            <p>First paragraph of continuous speech...</p>
            <p>Second paragraph if needed...</p>
            <p>Third paragraph...</p>
        </div>
    </div>
    \`\`\`
    This shows the speaker's name ONCE at the top, followed by all their dialogue content. Perfect for monologues or continuous speech.
4.  **CARDS**: Concepts must be in \`<div class="learning-card"><h3>Title</h3><p>Content</p></div>\`.
5.  **THINK PROMPTS**: For reflection moments, use \`<div class="think-prompt"><strong>ü§î Pause & Reflect:</strong> [question]</div>\`
6.  **NOTICE BOXES**: For language awareness, use \`<div class="notice-box"><strong>üëÅÔ∏è Notice:</strong> [pattern]</div>\`
7.  **SUCCESS INDICATORS**: Use \`<div class="success-badge">‚ú® [achievement]</div>\` for positive reinforcement
8.  **SENTENCE STEMS**: When providing scaffolding, use:
    \`\`\`html
    <div class="sentence-stems">
        <h4>üí¨ Use these sentence starters:</h4>
        <div class="stem-option">In my opinion, ___ because ___</div>
        <div class="stem-option">I believe that ___, whereas ___</div>
    </div>
    \`\`\`
9.  **SELF-ASSESSMENT**: After teaching moments, prompt metacognition:
    \`\`\`html
    <div class="self-check">
        <h4>How confident do you feel?</h4>
        <p style="font-size:0.9rem; margin:0.5rem 0;">Think about what we just covered...</p>
    </div>
    \`\`\`

### TEACHING APPROACH

**Scaffolding & Support**
- If student struggles: simplify, give examples, or provide sentence stems
- If student excels: ask follow-up questions or add complexity
- Show before you ask (model first, then elicit)

**Error Correction (be selective)**
- Don't correct every error - focus on what matters for this lesson
- Use gentle recasts: Student says "He go" ‚Üí You say "Yes, he goes every day"
- Only highlight persistent errors with \`<span class="hl-feedback">\`

**Maximize Student Talk**
- Ask open questions: "What do you think?" "Can you tell me more?"
- Wait for their responses - give them thinking time
- Don't fill every silence with more teacher talk

### TRACKER CONTROL
At the start of every message, you MUST output a hidden tag indicating the current stage from this list: [${STAGES.join(', ')}].
Format: \`[[STAGE: Pre task A (Activate)]]\`

### CONVERSATION PRINCIPLES
- Respond to what the student ACTUALLY says, not a script
- Follow natural conversation flow while gently guiding toward learning goals
- Be genuinely curious about their ideas
- Balance warmth with rigor
- Less is more - don't overwhelm with information
- Trust the process - deep learning takes time
`;

        // ===================================================================
        // RAG SYSTEM: STATE VARIABLES
        // ===================================================================
        let currentLesson = null;        // Parsed XML lesson data
        let studentProgress = null;      // Parsed JSON progress data
        let lessonEmbeddings = [];       // Embeddings for lesson content
        let progressEmbeddings = [];     // Embeddings for progress data

        // ===================================================================
        // SESSION TRACKING VARIABLES
        // ===================================================================
        let currentSession = null;       // Current session data being tracked
        let sessionStartTime = null;     // When the session started
        let currentStage = null;         // Current stage name
        let stagesCompletedInSession = []; // Stages completed in this session

        // Default lesson plan (fallback if no XML loaded)
        const DEFAULT_LESSON_PLAN = `
### LESSON PLAN (DEFAULT - B2: Travel Experiences)

**Topic**: Memorable Travel Experiences
**Level**: B2 (Upper Intermediate)
**Focus**: Narrative past tenses, descriptive vocabulary

1.  **Lead-in**: Quick question - "What's the last place you visited?"

2.  **Pre task A (Activate)**: ONE question in a card: "Think of a memorable trip. What made it special?"

3.  **Pre task B (Model)**: Short dialogue (5-6 lines) between two friends talking about a trip gone wrong/right.
    Example context: Sarah tells Marco about her surprising experience in Morocco.

4.  **Pre task C (Lang Focus)**: Highlight 2-3 useful expressions from the dialogue (e.g., "It turned out...", "I wasn't expecting...").
    Show pattern in a notice box. Give ONE example.

5.  **Pre task D (Pron)**: Focus on ONE pronunciation point (e.g., past tense endings -ed, or word stress).
    Model, then ask student to repeat 2-3 words.

6.  **Task Prep**: Brief prompt: "You're going to tell me about a trip - real or imaginary. Take a moment to think."
    Offer ONE sentence stem in a card if needed: "One time, I went to... and..."

7.  **Main Task**: Student shares their story. Listen actively. Ask 1-2 follow-up questions. Don't interrupt.

8.  **Reporting**: "How did that feel?" or "What was easy/hard about telling that story?"

9.  **Feedback**: Pick 1-2 specific things they did well. Recast 1-2 errors gently. End with encouragement.

REMEMBER: Keep your instructions short. One question at a time. Let the student talk more than you do.
`;

        // ===================================================================
        // RAG SYSTEM: CORE FUNCTIONS
        // ===================================================================

        // --- XML LESSON PARSER ---
        function parseXMLLesson(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            if (xmlDoc.querySelector('parsererror')) {
                throw new Error('Invalid XML format');
            }

            const lesson = {
                metadata: {
                    title: xmlDoc.querySelector('metadata title')?.textContent || 'Untitled Lesson',
                    level: xmlDoc.querySelector('metadata level')?.textContent || 'A1',
                    duration: xmlDoc.querySelector('metadata duration')?.textContent || '60',
                    topic: xmlDoc.querySelector('metadata topic')?.textContent || '',
                    keywords: xmlDoc.querySelector('metadata keywords')?.textContent || ''
                },
                objectives: [],
                lessonPlan: {},
                vocabularyBank: [],
                commonErrors: [],
                culturalContext: xmlDoc.querySelector('culturalContext')?.textContent?.trim() || ''
            };

            // Parse objectives
            xmlDoc.querySelectorAll('objectives objective').forEach(obj => {
                lesson.objectives.push(obj.textContent.trim());
            });

            // Parse lesson plan stages
            xmlDoc.querySelectorAll('lessonPlan stage').forEach(stage => {
                const stageName = stage.getAttribute('name');
                const stageData = {
                    order: stage.getAttribute('order'),
                    description: stage.querySelector('description')?.textContent?.trim() || '',
                    dialogue: null,
                    conceptChecks: stage.querySelector('conceptChecks')?.textContent?.trim() || '',
                    grammarFocus: stage.querySelector('grammarFocus')?.textContent?.trim() || '',
                    pronunciationFocus: stage.querySelector('pronunciationFocus')?.textContent?.trim() || '',
                    taskSetup: stage.querySelector('taskSetup')?.textContent?.trim() || '',
                    activity: stage.querySelector('activity')?.textContent?.trim() || '',
                    reflection: stage.querySelector('reflection')?.textContent?.trim() || '',
                    feedbackGuidance: stage.querySelector('feedbackGuidance')?.textContent?.trim() || ''
                };

                // Parse dialogue if present
                const dialogueEl = stage.querySelector('dialogue');
                if (dialogueEl) {
                    stageData.dialogue = {
                        title: dialogueEl.querySelector('title')?.textContent?.trim() || '',
                        context: dialogueEl.querySelector('context')?.textContent?.trim() || '',
                        speakers: []
                    };
                    dialogueEl.querySelectorAll('speaker').forEach(speaker => {
                        stageData.dialogue.speakers.push({
                            name: speaker.getAttribute('name'),
                            text: speaker.textContent.trim()
                        });
                    });
                }

                lesson.lessonPlan[stageName] = stageData;
            });

            // Parse vocabulary bank
            xmlDoc.querySelectorAll('vocabularyBank word').forEach(word => {
                lesson.vocabularyBank.push({
                    context: word.getAttribute('context'),
                    words: word.textContent.trim()
                });
            });

            // Parse common errors
            xmlDoc.querySelectorAll('commonErrors error').forEach(error => {
                lesson.commonErrors.push(error.textContent.trim());
            });

            return lesson;
        }

        // --- GENERATE LESSON PROMPT FROM XML ---
        function generateLessonPrompt(lesson) {
            if (!lesson) return DEFAULT_LESSON_PLAN;

            let prompt = `\n### LESSON INFORMATION
**Title**: ${lesson.metadata.title}
**Level**: ${lesson.metadata.level}
**Duration**: ${lesson.metadata.duration} minutes
**Topic**: ${lesson.metadata.topic}

### LESSON OBJECTIVES
${lesson.objectives.map((obj, i) => `${i + 1}. ${obj}`).join('\n')}

### LESSON PLAN
`;

            // Add each stage
            const stageOrder = Object.keys(lesson.lessonPlan).sort((a, b) => {
                return parseInt(lesson.lessonPlan[a].order) - parseInt(lesson.lessonPlan[b].order);
            });

            stageOrder.forEach((stageName, index) => {
                const stage = lesson.lessonPlan[stageName];
                prompt += `\n${index + 1}. **${stageName}**: `;

                if (stage.description) prompt += `\n${stage.description}`;

                if (stage.dialogue) {
                    prompt += `\n\n**Dialogue: ${stage.dialogue.title}**\n`;
                    prompt += `Context: ${stage.dialogue.context}\n\n`;
                    stage.dialogue.speakers.forEach(speaker => {
                        prompt += `${speaker.name}: ${speaker.text}\n\n`;
                    });
                }

                if (stage.conceptChecks) prompt += `\n\n**Concept Checks**:\n${stage.conceptChecks}`;
                if (stage.grammarFocus) prompt += `\n\n**Grammar Focus**:\n${stage.grammarFocus}`;
                if (stage.pronunciationFocus) prompt += `\n\n**Pronunciation**:\n${stage.pronunciationFocus}`;
                if (stage.taskSetup) prompt += `\n\n**Task Setup**:\n${stage.taskSetup}`;
                if (stage.activity) prompt += `\n\n**Activity**:\n${stage.activity}`;
                if (stage.reflection) prompt += `\n\n**Reflection**:\n${stage.reflection}`;
                if (stage.feedbackGuidance) prompt += `\n\n**Feedback Guidance**:\n${stage.feedbackGuidance}`;

                prompt += '\n';
            });

            if (lesson.vocabularyBank.length > 0) {
                prompt += `\n### VOCABULARY BANK\n`;
                lesson.vocabularyBank.forEach(item => {
                    prompt += `- ${item.context}: ${item.words}\n`;
                });
            }

            if (lesson.commonErrors.length > 0) {
                prompt += `\n### COMMON ERRORS TO WATCH FOR\n`;
                lesson.commonErrors.forEach(error => {
                    prompt += `- ${error}\n`;
                });
            }

            if (lesson.culturalContext) {
                prompt += `\n### CULTURAL CONTEXT\n${lesson.culturalContext}\n`;
            }

            prompt += `\nStart the conversation now with authentic presence.\n`;

            return prompt;
        }

        // --- GEMINI EMBEDDING API ---
        async function generateEmbedding(text) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${GEMINI_API_KEY}`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'models/text-embedding-004',
                        content: { parts: [{ text }] }
                    })
                });

                if (!response.ok) {
                    throw new Error(`Embedding API error: ${response.status}`);
                }

                const data = await response.json();
                return data.embedding.values;
            } catch (error) {
                console.error('Error generating embedding:', error);
                return null;
            }
        }

        // --- COSINE SIMILARITY ---
        function cosineSimilarity(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) return 0;

            let dotProduct = 0;
            let normA = 0;
            let normB = 0;

            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }

            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        // --- PROGRESS DATA PROCESSOR ---
        async function processProgressData(progressData) {
            if (!progressData || !progressData.sessions) return [];

            const chunks = [];

            // Create embeddings for recent sessions (last 5)
            const recentSessions = progressData.sessions.slice(-5);

            for (const session of recentSessions) {
                const sessionText = `
Session ${session.sessionId} - ${session.lessonTitle || 'Untitled'}
Date: ${session.date}
Stages completed: ${session.stagesCompleted?.map(s => s.name).join(', ') || 'None'}
Vocabulary learned: ${session.vocabularyLearned?.map(v => v.word).join(', ') || 'None'}
Grammar practiced: ${session.grammarPracticed?.map(g => g.point).join(', ') || 'None'}
Performance: Fluency ${session.assessmentScores?.fluency || 0}/10, Accuracy ${session.assessmentScores?.accuracy || 0}/10
                `.trim();

                const embedding = await generateEmbedding(sessionText);
                if (embedding) {
                    chunks.push({ text: sessionText, embedding, metadata: session });
                }
            }

            return chunks;
        }

        // --- RETRIEVE RELEVANT CONTEXT ---
        async function retrieveRelevantContext(query, maxChunks = 3) {
            if (progressEmbeddings.length === 0) {
                return ''; // No progress data loaded
            }

            const queryEmbedding = await generateEmbedding(query);
            if (!queryEmbedding) return '';

            // Calculate similarities
            const similarities = progressEmbeddings.map(chunk => ({
                text: chunk.text,
                similarity: cosineSimilarity(queryEmbedding, chunk.embedding),
                metadata: chunk.metadata
            }));

            // Sort by similarity and take top chunks
            similarities.sort((a, b) => b.similarity - a.similarity);
            const topChunks = similarities.slice(0, maxChunks);

            // Format context
            let context = '\n### STUDENT PROGRESS CONTEXT\n';
            context += 'Here is relevant information about the student based on their learning history:\n\n';

            topChunks.forEach(chunk => {
                if (chunk.similarity > 0.3) { // Threshold for relevance
                    context += `${chunk.text}\n\n`;
                }
            });

            // Add summary from cumulative progress
            if (studentProgress?.cumulativeProgress) {
                const cum = studentProgress.cumulativeProgress;
                context += `**Overall Progress Summary:**\n`;
                context += `- Total sessions: ${cum.totalSessions || 0}\n`;
                context += `- Total hours: ${cum.totalHours || 0}\n`;
                context += `- Vocabulary size: ${cum.vocabularySize || 0} words\n`;
                if (cum.currentStrengths?.length > 0) {
                    context += `- Strengths: ${cum.currentStrengths.join(', ')}\n`;
                }
                if (cum.currentWeaknesses?.length > 0) {
                    context += `- Areas to work on: ${cum.currentWeaknesses.join(', ')}\n`;
                }
            }

            // Add personalizations
            if (studentProgress?.personalizations) {
                const prefs = studentProgress.personalizations;
                context += `\n**Learning Preferences:**\n`;
                if (prefs.preferredPace) context += `- Preferred pace: ${prefs.preferredPace}\n`;
                if (prefs.respondsWellTo?.length > 0) {
                    context += `- Responds well to: ${prefs.respondsWellTo.join(', ')}\n`;
                }
                if (prefs.interests?.length > 0) {
                    context += `- Interests: ${prefs.interests.join(', ')}\n`;
                }
            }

            return context;
        }

        // --- COMPOSE FINAL PROMPT ---
        async function composeFinalPrompt() {
            let finalPrompt = BASE_PROMPT;

            // Add lesson prompt (from XML or default)
            const lessonPrompt = currentLesson ? generateLessonPrompt(currentLesson) : DEFAULT_LESSON_PLAN;
            finalPrompt += lessonPrompt;

            // Add student context (from RAG)
            if (studentProgress && progressEmbeddings.length > 0) {
                const context = await retrieveRelevantContext(
                    currentLesson ? `${currentLesson.metadata.title} ${currentLesson.metadata.topic}` : 'English lesson',
                    3
                );
                finalPrompt += context;
            }

            return finalPrompt;
        }

        // ===================================================================
        // SESSION TRACKING FUNCTIONS
        // ===================================================================

        // Initialize a new session
        function initializeSession() {
            sessionStartTime = new Date();
            const sessionId = `session_${Date.now()}`;

            currentSession = {
                sessionId: sessionId,
                date: sessionStartTime.toISOString(),
                lessonTitle: currentLesson ? currentLesson.metadata.title : "Default Lesson - Travel Experiences",
                duration: 0,
                stagesCompleted: [],
                vocabularyLearned: [],
                grammarPracticed: [],
                assessmentScores: {
                    fluency: 0,
                    accuracy: 0,
                    complexity: 0,
                    pronunciation: 0
                }
            };

            stagesCompletedInSession = [];
        }

        // Track stage completion
        function trackStageCompletion(stageName) {
            if (currentStage !== stageName) {
                currentStage = stageName;

                // Add to session if not already tracked
                if (!stagesCompletedInSession.includes(stageName)) {
                    stagesCompletedInSession.push(stageName);

                    if (currentSession) {
                        currentSession.stagesCompleted.push({
                            name: stageName,
                            completed: true,
                            timeSpent: 0, // Could be calculated if needed
                            performance: "moderate"
                        });
                    }
                }
            }
        }

        // Track vocabulary from the vocabulary wallet
        function trackSessionVocabulary() {
            if (currentSession && vocabularyWords.size > 0) {
                currentSession.vocabularyLearned = Array.from(vocabularyWords).map(word => ({
                    word: word,
                    context: "",
                    mastery: 0.7,
                    reviewCount: 1
                }));
            }
        }

        // Update progress JSON with current session
        function updateProgressWithSession() {
            if (!currentSession) return null;

            // Calculate session duration
            const endTime = new Date();
            currentSession.duration = Math.round((endTime - sessionStartTime) / 60000); // minutes

            // Track vocabulary one more time before saving
            trackSessionVocabulary();

            // Initialize student progress if it doesn't exist
            if (!studentProgress) {
                studentProgress = {
                    studentId: "student_" + Date.now(),
                    profile: {
                        name: "Anonymous Student",
                        currentLevel: "B2",
                        nativeLanguage: "Unknown",
                        learningGoals: ["Improve conversational fluency"]
                    },
                    sessions: [],
                    cumulativeProgress: {
                        totalSessions: 0,
                        totalHours: 0,
                        vocabularySize: 0,
                        grammarPointsMastered: [],
                        grammarPointsInProgress: [],
                        currentWeaknesses: [],
                        currentStrengths: []
                    },
                    personalizations: {
                        preferredPace: "moderate",
                        respondsWellTo: [],
                        avoidsTriggersRelatedTo: [],
                        culturalBackground: "",
                        interests: [],
                        learningStyle: {
                            visualLearner: true,
                            auditoryLearner: false,
                            kinestheticLearner: false,
                            needsExtraTime: false,
                            prefersStructure: true
                        }
                    }
                };
            }

            // Add current session to sessions array
            studentProgress.sessions.push(currentSession);

            // Update cumulative progress
            studentProgress.cumulativeProgress.totalSessions = studentProgress.sessions.length;
            studentProgress.cumulativeProgress.totalHours = Math.round(
                (studentProgress.cumulativeProgress.totalHours || 0) + (currentSession.duration / 60) * 10
            ) / 10;

            // Update vocabulary size
            const allVocab = new Set();
            studentProgress.sessions.forEach(session => {
                session.vocabularyLearned?.forEach(v => allVocab.add(v.word.toLowerCase()));
            });
            studentProgress.cumulativeProgress.vocabularySize = allVocab.size;

            return studentProgress;
        }

        // Download updated progress JSON
        function downloadProgressJSON() {
            const updatedProgress = updateProgressWithSession();
            if (!updatedProgress) {
                alert('No session data to save. Complete a lesson first!');
                return;
            }

            const jsonString = JSON.stringify(updatedProgress, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `student-progress-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- LOCALSTORAGE PERSISTENCE ---
        function saveToLocalStorage() {
            try {
                if (currentLesson) {
                    localStorage.setItem('nour_current_lesson', JSON.stringify(currentLesson));
                }
                if (studentProgress) {
                    localStorage.setItem('nour_student_progress', JSON.stringify(studentProgress));
                }
            } catch (error) {
                console.error('LocalStorage error:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const savedLesson = localStorage.getItem('nour_current_lesson');
                const savedProgress = localStorage.getItem('nour_student_progress');

                if (savedLesson) {
                    currentLesson = JSON.parse(savedLesson);
                    updateLessonStatus();
                }
                if (savedProgress) {
                    studentProgress = JSON.parse(savedProgress);
                    updateProgressStatus();
                    // Regenerate embeddings
                    processProgressData(studentProgress).then(chunks => {
                        progressEmbeddings = chunks;
                    });
                }
            } catch (error) {
                console.error('LocalStorage load error:', error);
            }
        }

        // --- UPDATE UI STATUS ---
        function updateLessonStatus() {
            const statusEl = document.getElementById('lesson-status');
            if (currentLesson) {
                statusEl.textContent = `‚úì ${currentLesson.metadata.title} (${currentLesson.metadata.level})`;
                statusEl.style.color = 'var(--primary-color)';
                statusEl.style.fontStyle = 'normal';
            } else {
                statusEl.textContent = 'No lesson loaded';
                statusEl.style.color = '#999';
                statusEl.style.fontStyle = 'italic';
            }
        }

        function updateProgressStatus() {
            const statusEl = document.getElementById('progress-status');
            if (studentProgress) {
                const sessions = studentProgress.sessions?.length || 0;
                const vocab = studentProgress.cumulativeProgress?.vocabularySize || 0;
                statusEl.textContent = `‚úì ${sessions} sessions, ${vocab} words`;
                statusEl.style.color = 'var(--primary-color)';
                statusEl.style.fontStyle = 'normal';
            } else {
                statusEl.textContent = 'No progress data';
                statusEl.style.color = '#999';
                statusEl.style.fontStyle = 'italic';
            }
        }

        // --- FILE UPLOAD HANDLERS ---
        async function handleLessonUpload(file) {
            try {
                const text = await file.text();
                currentLesson = parseXMLLesson(text);
                updateLessonStatus();
                saveToLocalStorage();

                // Reset chat to use new lesson
                chatHistory = [];
                chatEl.innerHTML = '';

                await appendMessage('ai', 'üîÑ New lesson loaded! Ready to start with: **' + currentLesson.metadata.title + '**');
            } catch (error) {
                await appendMessage('error', 'Failed to load lesson file: ' + error.message);
            }
        }

        async function handleProgressUpload(file) {
            try {
                const text = await file.text();
                studentProgress = JSON.parse(text);
                updateProgressStatus();
                saveToLocalStorage();

                // Generate embeddings for progress data
                await appendMessage('ai', '‚öôÔ∏è Processing your progress data...');
                progressEmbeddings = await processProgressData(studentProgress);

                await appendMessage('ai', `‚úÖ Progress data loaded! I can see you've completed ${studentProgress.sessions?.length || 0} sessions. I'll use this to personalize our lesson.`);
            } catch (error) {
                await appendMessage('error', 'Failed to load progress file: ' + error.message);
            }
        }

        // --- UI LOGIC ---
        const chatEl = document.getElementById('chat-history');
        const inputEl = document.getElementById('user-input');
        const trackerContainer = document.getElementById('tracker-container');
        let chatHistory = [];
        let isMuted = false;

        // Vocabulary Tracker
        let vocabularyWords = new Set();

        function updateVocabularyWallet(text) {
            // Extract vocabulary words from hl-vocab spans
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            const vocabSpans = tempDiv.querySelectorAll('.hl-vocab');

            vocabSpans.forEach(span => {
                const word = span.textContent.trim();
                if (word && !vocabularyWords.has(word.toLowerCase())) {
                    vocabularyWords.add(word.toLowerCase());
                    addVocabToWallet(word);
                }
            });
        }

        function addVocabToWallet(word) {
            const walletEl = document.getElementById('vocab-wallet');

            // Remove empty state message if it exists
            if (walletEl.children.length === 1 && walletEl.children[0].textContent.includes('Vocabulary words will appear')) {
                walletEl.innerHTML = '';
            }

            // Create vocabulary item
            const vocabItem = document.createElement('div');
            vocabItem.className = 'vocab-item';
            vocabItem.innerHTML = `
                <span class="vocab-word">${word}</span>
            `;

            // Add to top of wallet
            walletEl.insertBefore(vocabItem, walletEl.firstChild);

            // Limit to 20 most recent items
            if (walletEl.children.length > 20) {
                walletEl.removeChild(walletEl.lastChild);
            }
        }

        // Initialize Tracker
        function initTracker() {
            trackerContainer.innerHTML = '';
            STAGES.forEach((stage, i) => {
                const el = document.createElement('div');
                el.className = `step-item ${i === 0 ? 'active' : ''}`;
                el.id = `stage-${i}`;
                el.innerHTML = `<div class="step-dot"></div><div class="step-title">${stage}</div>`;
                trackerContainer.appendChild(el);
            });
        }

        function updateTracker(stageName) {
            const idx = STAGES.findIndex(s => stageName.toLowerCase().includes(s.toLowerCase().split(' ')[0].toLowerCase()));
            if (idx !== -1) {
                for(let i=0; i<idx; i++) {
                    document.getElementById(`stage-${i}`).classList.remove('active');
                    document.getElementById(`stage-${i}`).classList.add('done');
                }
                const curr = document.getElementById(`stage-${idx}`);
                curr.classList.remove('done');
                curr.classList.add('active');
                curr.scrollIntoView({behavior: 'smooth', block: 'center'});
            }
        }

        // --- MARKDOWN & PARSING ---
        // Ensure we handle [object Object] by properly extracting text
        async function appendMessage(role, text) {
            const div = document.createElement('div');
            div.className = `message ${role}`;
            
            // Clean tags for display
            let displayHtml = text.replace(/\[\[STAGE:.*?\]\]/g, '');
            
            // Render Markdown/HTML
            try {
                // If marked isn't loaded for some reason, fallback to text
                if (typeof marked !== 'undefined') {
                    div.innerHTML = marked.parse(displayHtml);
                } else {
                    div.innerHTML = displayHtml;
                }
            } catch (e) {
                console.error("Markdown Error", e);
                div.textContent = displayHtml;
            }

            chatEl.appendChild(div);
            // Wait for images/layout before scrolling
            requestAnimationFrame(() => {
                chatEl.scrollTo({ top: chatEl.scrollHeight, behavior: 'smooth' });
            });
        }

        async function processAIResponse(rawText) {
            // Extract Stage
            const stageMatch = rawText.match(/\[\[STAGE:\s*(.*?)\]\]/);
            if (stageMatch) {
                const stageName = stageMatch[1];
                updateTracker(stageName);
                trackStageCompletion(stageName); // Track in session
            }

            // Update vocabulary wallet with new words
            updateVocabularyWallet(rawText);

            return rawText;
        }

        // --- API CALL WITH RETRY LOGIC ---
        async function sendMessage() {
            const text = inputEl.value.trim();
            if (!text) return;

            inputEl.value = '';
            appendMessage('user', text);

            document.getElementById('header-status').textContent = "Thinking...";
            document.getElementById('avatar-wrapper').classList.add('listening');

            chatHistory.push({ role: "user", parts: [{ text: text }] });

            // RAG: Compose final prompt with BASE + LESSON + CONTEXT
            const finalPrompt = await composeFinalPrompt();

            // Retry logic for network stability
            let retries = 3;
            let lastError;

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: chatHistory,
                            system_instruction: { parts: [{ text: finalPrompt }] }
                        }),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error.message);
                    }

                    if (!data.candidates || !data.candidates[0].content) {
                        throw new Error("Empty response from AI");
                    }

                    const aiText = data.candidates[0].content.parts[0].text;

                    const processedText = await processAIResponse(aiText);
                    appendMessage('ai', processedText);

                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });

                    if (!isMuted) speak(processedText);

                    // Success - break retry loop
                    break;

                } catch (error) {
                    lastError = error;
                    console.error(`Attempt ${attempt + 1} failed:`, error);

                    if (attempt < retries) {
                        // Wait before retry (exponential backoff)
                        const waitTime = Math.min(1000 * Math.pow(2, attempt), 5000);
                        document.getElementById('header-status').textContent = `Retrying... (${attempt + 1}/${retries})`;
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    } else {
                        // All retries failed
                        appendMessage('error', `Connection error: ${lastError.message}. Please check your internet connection and try again.`);
                    }
                }
            }

            document.getElementById('header-status').textContent = "Online";
            document.getElementById('avatar-wrapper').classList.remove('listening');
        }

        // --- SPEECH RECOGNITION (FIXED) ---
        let recognition;
        const micBtn = document.getElementById('mic-btn');
        
        // Browser compatibility check
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                micBtn.classList.add('listening');
                inputEl.placeholder = "Listening...";
            };
            
            recognition.onend = () => {
                micBtn.classList.remove('listening');
                inputEl.placeholder = "Type or tap microphone...";
                // Trigger send automatically if desired, or let user click send
            };
            
            recognition.onerror = (event) => {
                console.error("Speech Error:", event.error);
                micBtn.classList.remove('listening');
                alert("Microphone error: " + event.error);
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                inputEl.value = transcript;
            };

            micBtn.addEventListener('click', () => {
                if (micBtn.classList.contains('listening')) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });
        } else {
            micBtn.style.display = 'none'; // Hide if not supported
            console.log("Speech Recognition not supported in this browser.");
        }

        // --- TEXT TO SPEECH (Browser Speech Synthesis) ---
        let currentUtterance = null;
        let voicesLoaded = false;
        let preferredVoice = null;

        // Initialize voices when available
        function initVoices() {
            const synth = window.speechSynthesis;
            const voices = synth.getVoices();

            if (voices.length > 0) {
                voicesLoaded = true;
                // Try to find a quality female voice
                preferredVoice = voices.find(voice =>
                    voice.name.includes('Google UK English Female') ||
                    voice.name.includes('Microsoft Zira') ||
                    voice.name.includes('Samantha') ||
                    voice.name.includes('Karen') ||
                    voice.name.includes('Victoria') ||
                    voice.name.includes('Female')
                ) || voices.find(voice => voice.lang.startsWith('en'));
            }
        }

        // Load voices on page load and when they change
        if (window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = initVoices;
            initVoices();
        }

        async function speak(text) {
            // Clean HTML tags and special markers for speech
            const cleanText = text.replace(/<[^>]*>/g, '').replace(/\[\[.*?\]\]/g, '').trim();

            if (!cleanText || isMuted) return;

            const synth = window.speechSynthesis;

            // Cancel any ongoing speech
            if (synth.speaking) {
                synth.cancel();
            }

            // Wait for voices to load if not ready
            if (!voicesLoaded) {
                initVoices();
                // If still not loaded, wait a bit
                if (!voicesLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    initVoices();
                }
            }

            document.getElementById('avatar-wrapper').classList.add('speaking');

            // Split text into chunks (speech synthesis has character limits)
            const chunks = splitTextIntoChunks(cleanText, 150);

            // Speak each chunk sequentially
            speakChunks(chunks, 0);
        }

        function splitTextIntoChunks(text, maxLength) {
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            const chunks = [];
            let currentChunk = '';

            for (const sentence of sentences) {
                if ((currentChunk + sentence).length > maxLength && currentChunk) {
                    chunks.push(currentChunk.trim());
                    currentChunk = sentence;
                } else {
                    currentChunk += ' ' + sentence;
                }
            }

            if (currentChunk.trim()) {
                chunks.push(currentChunk.trim());
            }

            return chunks;
        }

        function speakChunks(chunks, index) {
            if (index >= chunks.length || isMuted) {
                document.getElementById('avatar-wrapper').classList.remove('speaking');
                return;
            }

            const synth = window.speechSynthesis;

            // Safety check - cancel if synth is stuck
            if (synth.pending) {
                synth.cancel();
            }

            const utterThis = new SpeechSynthesisUtterance(chunks[index]);

            // Configure voice
            utterThis.pitch = 1.0;
            utterThis.rate = 0.92;
            utterThis.volume = 1.0;

            // Use preferred voice if available
            if (preferredVoice) {
                utterThis.voice = preferredVoice;
            }

            utterThis.onend = () => {
                // Small delay between chunks for natural pacing
                setTimeout(() => {
                    speakChunks(chunks, index + 1);
                }, 50);
            };

            utterThis.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                // Try to continue with next chunk on error
                if (event.error !== 'canceled') {
                    setTimeout(() => {
                        speakChunks(chunks, index + 1);
                    }, 100);
                } else {
                    document.getElementById('avatar-wrapper').classList.remove('speaking');
                }
            };

            // Add small delay before speaking to ensure synth is ready
            setTimeout(() => {
                synth.speak(utterThis);
                currentUtterance = utterThis;
            }, 10);
        }

        document.getElementById('sound-btn').addEventListener('click', function() {
            isMuted = !isMuted;
            this.style.opacity = isMuted ? '0.5' : '1';
            if (isMuted && window.speechSynthesis) {
                window.speechSynthesis.cancel();
                document.getElementById('avatar-wrapper').classList.remove('speaking');
            }
        });

        // --- INITIALIZATION ---
        document.getElementById('start-session-btn').addEventListener('click', async () => {
            const key = document.getElementById('api-key-input').value;
            if (key) {
                GEMINI_API_KEY = key;
                document.getElementById('api-modal').style.display = 'none';
                initTracker();

                // Initialize session tracking
                initializeSession();

                // Load saved lesson and progress from localStorage
                loadFromLocalStorage();

                // Auto-start conversation
                document.getElementById('header-status').textContent = "Initializing...";
                document.getElementById('avatar-wrapper').classList.add('listening');

                try {
                    // RAG: Compose final prompt
                    const finalPrompt = await composeFinalPrompt();

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [
                                {
                                    role: "user",
                                    parts: [{ text: "Hello" }]
                                }
                            ],
                            system_instruction: { parts: [{ text: finalPrompt }] }
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error.message);
                    }

                    if (data.candidates && data.candidates[0].content) {
                        const aiText = data.candidates[0].content.parts[0].text;
                        const processedText = await processAIResponse(aiText);
                        appendMessage('ai', processedText);
                        chatHistory.push({ role: "user", parts: [{ text: "Hello" }] });
                        chatHistory.push({ role: "model", parts: [{ text: aiText }] });

                        if (!isMuted) speak(processedText);
                    }
                } catch (error) {
                    console.error(error);
                    appendMessage('error', `Error: ${error.message}`);
                } finally {
                    document.getElementById('header-status').textContent = "Online";
                    document.getElementById('avatar-wrapper').classList.remove('listening');
                }
            }
        });

        document.getElementById('send-btn').addEventListener('click', sendMessage);

        // Enter key to send (Shift+Enter for new line)
        inputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Auto-resize textarea and add typing indicator
        let typingTimeout;
        inputEl.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';

            // Add typing indicator to avatar
            const avatarWrapper = document.getElementById('avatar-wrapper');
            avatarWrapper.classList.add('typing');

            // Clear previous timeout
            clearTimeout(typingTimeout);

            // Remove typing indicator after user stops typing
            typingTimeout = setTimeout(() => {
                avatarWrapper.classList.remove('typing');
            }, 1000);
        });

        // --- FILE UPLOAD EVENT LISTENERS ---
        document.getElementById('lesson-upload-btn').addEventListener('click', () => {
            document.getElementById('lesson-upload').click();
        });

        document.getElementById('lesson-upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleLessonUpload(file);
            }
        });

        document.getElementById('progress-upload-btn').addEventListener('click', () => {
            document.getElementById('progress-upload').click();
        });

        document.getElementById('progress-upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await handleProgressUpload(file);
            }
        });

        document.getElementById('theme-btn').addEventListener('click', () => {
            document.body.classList.toggle('theme-ocean');
            // Re-init canvas colors
            initWaves();
        });

        // --- CANVAS BACKGROUND (Performance Optimized) ---
        const canvas = document.getElementById('wave-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let waves = [];
        let animationFrameId;

        // Check if device prefers reduced motion or is low-end
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const isLowEndDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4;

        function initWaves() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            const style = getComputedStyle(document.body);
            const p = style.getPropertyValue('--primary-color').trim();

            // Helper to get RGB from hex
            const hex2rgba = (hex, alpha = 1) => {
                const [r, g, b] = hex.match(/\w\w/g).map(x => parseInt(x, 16));
                return `rgba(${r},${g},${b},${alpha})`;
            };

            const color = p.startsWith('#') ? hex2rgba(p, 0.1) : 'rgba(100,100,100,0.1)';

            // Reduce waves on low-end devices
            if (isLowEndDevice || prefersReducedMotion) {
                waves = [
                    { y: height * 0.65, length: 0.002, amp: 50, speed: 0.001, offset: 0 }
                ];
            } else {
                waves = [
                    { y: height * 0.6, length: 0.002, amp: 60, speed: 0.002, offset: 0 },
                    { y: height * 0.65, length: 0.003, amp: 40, speed: 0.003, offset: 2 },
                    { y: height * 0.7, length: 0.001, amp: 80, speed: 0.001, offset: 4 }
                ];
            }

            // Cancel previous animation if exists
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Start animation
            if (!prefersReducedMotion) {
                draw();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            const style = getComputedStyle(document.body);
            const p = style.getPropertyValue('--primary-color').trim();
            ctx.fillStyle = p.startsWith('#') ? p + '1A' : 'rgba(100,100,100,0.1)';

            waves.forEach(w => {
                ctx.beginPath();
                ctx.moveTo(0, height);
                ctx.lineTo(0, w.y);

                // Reduce resolution on low-end devices
                const step = (isLowEndDevice || prefersReducedMotion) ? 20 : 10;
                for (let x = 0; x <= width; x += step) {
                    ctx.lineTo(x, w.y + Math.sin(x * w.length + w.offset) * w.amp);
                }
                ctx.lineTo(width, height);
                ctx.fill();
                w.offset += w.speed;
            });

            animationFrameId = requestAnimationFrame(draw);
        }

        // Debounced resize handler
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(initWaves, 200);
        });

        initWaves();

        // --- PDF GENERATION (IMPROVED) ---
        document.getElementById('download-report-btn').addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // Color scheme from css.html
            const sageGreen = [74, 89, 42];    // --dark-olive
            const accentOrange = [235, 160, 60]; // --marigold
            const textDark = [42, 51, 40];     // --ink

            // Header with gradient effect
            doc.setFillColor(...sageGreen);
            doc.rect(0, 0, 210, 35, 'F');

            // Title
            doc.setFontSize(24);
            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            doc.text('Nour Learning Report', 105, 18, { align: 'center' });

            // Date
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            const today = new Date().toLocaleDateString('en-US', {
                year: 'numeric', month: 'long', day: 'numeric'
            });
            doc.text(today, 105, 27, { align: 'center' });

            let y = 50;

            // Session Summary Box
            if (currentSession) {
                doc.setFillColor(245, 241, 230); // --cream
                doc.roundedRect(15, y - 5, 180, 25, 3, 3, 'F');

                doc.setFontSize(10);
                doc.setTextColor(...textDark);
                doc.setFont(undefined, 'bold');
                doc.text('Lesson: ', 20, y);
                doc.setFont(undefined, 'normal');
                doc.text(currentSession.lessonTitle, 45, y);

                doc.setFont(undefined, 'bold');
                doc.text('Duration: ', 20, y + 7);
                doc.setFont(undefined, 'normal');
                doc.text(`${currentSession.duration} minutes`, 45, y + 7);

                doc.setFont(undefined, 'bold');
                doc.text('Stages Completed: ', 20, y + 14);
                doc.setFont(undefined, 'normal');
                doc.text(`${stagesCompletedInSession.length} of ${STAGES.length}`, 60, y + 14);

                y += 35;
            }

            // Section: Vocabulary Learned
            doc.setFontSize(16);
            doc.setTextColor(...sageGreen);
            doc.setFont(undefined, 'bold');
            doc.text('üìö Vocabulary Learned', 20, y);

            // Decorative line under heading
            doc.setDrawColor(...accentOrange);
            doc.setLineWidth(2);
            doc.line(20, y + 2, 50, y + 2);

            y += 12;

            doc.setFontSize(10);
            doc.setTextColor(...textDark);
            doc.setFont(undefined, 'normal');

            if (vocabularyWords.size > 0) {
                const vocabArray = Array.from(vocabularyWords);

                // Display vocabulary in a nice grid
                let col = 0;
                vocabArray.forEach((word, index) => {
                    if (y > 265) {
                        doc.addPage();
                        y = 20;
                    }

                    const xPos = 25 + (col * 85);

                    // Vocabulary badge
                    doc.setFillColor(255, 232, 204); // Light orange
                    doc.roundedRect(xPos - 3, y - 5, 75, 9, 2, 2, 'F');
                    doc.setTextColor(...accentOrange);
                    doc.setFont(undefined, 'bold');
                    doc.text(word, xPos, y);

                    col++;
                    if (col > 1) {
                        col = 0;
                        y += 12;
                    }
                });

                if (col !== 0) y += 12;
                y += 10;
            } else {
                doc.text('No vocabulary words recorded in this session.', 25, y);
                y += 20;
            }

            // Section: Key Stages
            if (stagesCompletedInSession.length > 0) {
                doc.setFontSize(16);
                doc.setTextColor(...sageGreen);
                doc.setFont(undefined, 'bold');
                doc.text('‚úì Completed Stages', 20, y);

                doc.setDrawColor(...accentOrange);
                doc.setLineWidth(2);
                doc.line(20, y + 2, 60, y + 2);

                y += 12;

                doc.setFontSize(10);
                doc.setTextColor(...textDark);
                doc.setFont(undefined, 'normal');

                stagesCompletedInSession.forEach(stage => {
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.text(`‚úì ${stage}`, 25, y);
                    y += 7;
                });

                y += 10;
            }

            // Conversation Highlights
            doc.setFontSize(16);
            doc.setTextColor(...sageGreen);
            doc.setFont(undefined, 'bold');
            doc.text('üí¨ Conversation Highlights', 20, y);

            doc.setDrawColor(...accentOrange);
            doc.setLineWidth(2);
            doc.line(20, y + 2, 75, y + 2);

            y += 12;

            doc.setFontSize(9);
            doc.setTextColor(...textDark);

            // Extract clean text from chat (limit to key messages)
            const keyMessages = chatHistory.slice(-10); // Last 10 messages
            keyMessages.forEach((msg, i) => {
                if (y > 265) {
                    doc.addPage();
                    y = 20;
                }

                const role = msg.role === 'user' ? 'You' : 'Nour';
                const text = msg.parts[0].text
                    .replace(/<[^>]*>/g, '')
                    .replace(/\[\[STAGE:.*?\]\]/g, '')
                    .substring(0, 150);

                doc.setFont(undefined, 'bold');
                doc.setTextColor(...(msg.role === 'user' ? accentOrange : sageGreen));
                doc.text(`${role}:`, 20, y);

                doc.setFont(undefined, 'normal');
                doc.setTextColor(...textDark);
                const lines = doc.splitTextToSize(text, 165);
                doc.text(lines.slice(0, 2), 20, y + 5);

                y += 5 + (Math.min(lines.length, 2) * 5) + 5;
            });

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(150);
                doc.text(
                    'Generated by Nour AI Tutor | Keep practicing, keep growing! üå±',
                    105,
                    285,
                    { align: 'center' }
                );
                doc.text(`Page ${i} of ${pageCount}`, 105, 290, { align: 'center' });
            }

            doc.save(`nour-lesson-report-${Date.now()}.pdf`);
        });

        // --- PROGRESS JSON DOWNLOAD ---
        document.getElementById('download-progress-btn').addEventListener('click', downloadProgressJSON);

    </script>
</body>
</html>
```
